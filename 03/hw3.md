Домашнее задание №3

Дедлайн - 3 недели с момента лекции, на которой была выдана домашка.

---------

Это комбинированное задание по тому, как отправлять запросы, получать ответы, работать с параметрами, хедерами, а так же писать тесты.

Задание не сложное, основной объёма работы - написание разных условий и тестов, чтобы эти условия удовлетворить.

Делается за 3-5 часов.

У нас есть какой-то поисковый сервис:

* SearchClient - структура с методом FindUsers, который отправляет запрос во внешнюю систему и возвращает результат, немного преобразуя его. Код написан.
* SearchServer - своего рода внешняя система. Непосредственно занимается поиском данных в файле `dataset.xml`. В продакшене бы запускалась в виде отдельного веб-сервиса. Код необходимо написать вам.

Требуется:

* Написать функцию SearchServer в файле `server.go`, который вы будете запускать через тестовый сервер (`httptest.NewServer`, пример использования в `3/4_http_testing/server_test.go`)
* Покрыть тестами метод FindUsers, чтобы покрытие было 100%. Тесты писать в `coverage_test.go`.
* Тесты так же должны обеспечить 100%-е покрытие SearchServer. Там придётся подменять в некоторых случаях путь до файла (имя файла можно сделать глобальной переменной), чтобы ошибку получить, или же сам файл.
* Так же требуется сгенерировать html-отчет с покрытием. См. пример построения тестового покрытия и отчета в 3/3_testing/.
* Тесты писать полноценное, т.е. они реально должны проверять что другая сторона вернула корректный ответ, а не просто покрытие обеспечилось. Это значит, что вы должны реально искать по файлу, реально возвращать результаты, а в тесте смотреть что вернулось то, что вы забили в тест. В сравниваемых тестовых данных жестко указать записи не считается хардкодом.

Дополнительно:

* Данные для работы лежит в файле `dataset.xml`
* Параметр `query` ищет по полям `Name` и `About`
* Параметр `order_field` работает по полям `Id`, `Age`, `Name`, если пустой - то возвращаем по `Name`, если что-то другое - SearchServer ругается ошибкой. `Name` - это first_name + last_name из xml.
* Параметр `order_by` задает направление сортировки (по полю переданному в `order_field`) или ее отсутствие (OrderByAsIs)
* Параметры `offset` и `limit` позволяют получать отсортированный список юзеров пачками с индекса `offset` не более `limit` штук.
* Если `query` пустой, то делаем только сортировку, т.е. возвращаем все записи
* Код нужно писать в файле coverage_test.go и server.go. Файл client.go трогать не надо
* Как работать с XML смотрите в `3/6_xml/*`
* Запускать как `go test -cover`
* Построение покрытия: `go test -coverprofile=cover.out && go tool cover -html=cover.out -o cover.html`.
* В XML 2 поля с именем, наше поле Name это first_name + last_name из XML
* <https://www.golangprograms.com/files-directories-examples.html> - в помощь для работы с файлами
* проверка ошибок в функциях io.WriteString, io.ReadAll(и аналогичных им, что читают из Reader, пишут во Writer), а также json.Marshal должны быть, но их можно не покрывать тестами. но если все же хочется чистых 100%, то вот подсказка: чтоб это было проще покрыть тестами можно сделать отдельную функцию для парсинга входящих параметров и отдельную для сериализации и отправки ответа, тогда довольно легко будет описать отдельный тест на негативные сценарии этих функций. что касается xml, то там можно обойтись без ReadAll если парсить через Decoder

Советы:

* Документация <https://golang.org/pkg/net/http/> может помочь
* Не запихивайте всё в 1 тест, напишите несколько табличных тестов по назначению - параметры, ошибки
* Вы можете не ограничиваться функцией SearchServer при тестировании, если вам надо проверить какой-то совсем отдельный хитрый кейс, вроде ошибки. Но таких случаев будет немного. В основном всё будет в SearchServer
* Для покрытия тестом одной из ошибок придётся залезть в исходники функции, которая возвращает эту ошибку, и посмотреть при каких условиях работы или входных данных это происходит
* Производительность, горутины и прочий асинхрон в этом задании не нужны

* Пример `order_by=-1&order_field=age&limit=1&offset=0&query=on` вернет 1 юзера с максимальным возрастом из тех, у которого в Name или About есть строка `on`
